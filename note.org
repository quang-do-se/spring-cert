#+STARTUP: showall

* An application programming interface (API) describes what a class/method does; a Service Provider Interface (SPI) describes what you need to extend and implement.


* There are 2 types of IoC containers:
  - org.springframework.beans.factory.BeanFactory (interface)
  - org.springframework.context.ApplicationContext (interface)

** BeanFactory vs ApplicationContext
   - ApplicationContext is more advanded than BeanFactory
   - ApplicationContext is a superset and also implements BeanFactory interface
   - ApplicationContext provides life cycle management for Spring Beans
   - BeanFactory is the root inteface for accessing a Spring Bean container


* Spring IoC container:
** Components
   - The Core libraries from Spring Framework (Inversion of Control and Dependency Injection)
   - Context - virtual memory location inside Spring Framework
     - All the configurations how to create a bin
     - Dependencies that it has
     - The intial values for that bin
   - Beans (simple POJOs)
   - Spring Expression Language (SPEL)

** The configuration metadata is represented in XML, Java annotations, or Java code.

** Spring prefer Unchecked Exceptions as it gives developers freedom of choice as to decide where to implement error handling and removes coupling related to exceptions. It also removes cluttered code as there is no requirement of try-catch blocks.

** You may declare @Bean methods as static, allowing for them to be called without creating their containing configuration class as an instance. This makes particular sense when defining post-processor beans, e.g. of type BeanFactoryPostProcessor or BeanPostProcessor, since such beans will get initialized early in the container lifecycle and should avoid triggering other parts of the configuration at that point.

   - Note that calls to static @Bean methods will never get intercepted by the container, not even within @Configuration classes (see above). This is due to technical limitations: CGLIB subclassing can only override non-static methods. As a consequence, a direct call to another @Bean method will have standard Java semantics, resulting in an independent instance being returned straight from the factory method itself.

   - https://docs.spring.io/spring-framework/docs/5.0.5.RELEASE/spring-framework-reference/core.html#beans-factorybeans-annotations


* Autowiring
** Precedence
   - Type (class, abstract, interface...)
   - @Qualifier
   - @Primary
   - Bean Name - @Bean("<name>"), @Component("<name>"), @Named("<name")

*** If both the @Qualifier and @Primary annotations are present, then the @Qualifier annotation will have precedence. Basically, @Primary defines a default, while @Qualifier is very specific.

*** @Qualifier > @Primary > Bean Name

*** If there is only one instance of the bean type, it does not really matter the bean name.

** @Autowired supports Generic Types.

** @Autowired supports Arrays, Collections, and Maps

** There should be only ONE @Autowired constructor in a class

** @Autowired attribute "required" can only be used with setters. NOT constructor. Constructor injection is always "mandatory".
   - @Required is alternative but deprecated.

** @Autowired Constructor and Setter can be used together

** Setters' method name DO NOT NEED to start with "set...()" to be autowired

** Constructor should have NO more than 6 arguments

** Typed Map collection can be autowired as long as the expected key type is String.

   #+begin_src java
     @Autowired
     public void setMovieCatalogs(Map<String, MovieCatalog> movieCatalogs) {
         this.movieCatalogs = movieCatalogs;
     }
   #+end_src


* Bean order annotation (annotation that affect the order in which the IoC Container instantiates beans)

** @Order - directly specifies the order in which beans are instantiated.
** @Lazy - makes the Container only instantiate the annotated bean when it is called.
** @DependsOn - make sure that the annotated beans are instantiated after their dependencies.
** @Import -  make sure that the annotated beans are instantiated after their dependencies.


* Try to avoid @Lazy, it can cause some errors not catched early


* Alias
  - Currently cannot create Aliases for stereotype annotation
  - This can be done with @Bean annotation
    - The first alias will be the unique identifier for the bean
    - Everything after that will be treated as alias

    #+begin_src java
      @Bean(name= {"beanOne", "beanTwo"})
      SimpleBean simpleBean(){
          return new SimpleBeanImpl();
      }
    #+end_src


* Using @Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE) does nothing by itself
  - The "proxyMode" attribute must be set

  - Be default, "proxyMode = ScopedProxyMode.DEFAULT" is used
    - DEFAULT typically equals NO proxy
    - SCOPE_PROTOTYPE will still have NO effect

  - If the class implements an interface, use "proxyMode = ScopedProxyMode.INTERFACES"
    - The IoC container will create a JDK interface-based dynamic proxy
    - Can only intercept public and default methods.
      - Starting with Java 8, interfaces can be declared to contain private and default methods. For obvious reasons, related to their access modifier, private methods are not proxied. Default methods are methods that are declared in the interface, so that classes implementing the interface donâ€™t have to. They are inherited by the classes, so they are proxied just like any normal method, with the specific behavior being executed before the call being forwarded to the target object.

  - If the class does not implement an interface, use "proxyMode = ScopedProxyMode.TARGET_CLASS"
    - The IoC container will create a CGLIB-based class proxy.
    - Can only intercept public and protected methods (and even package-visible methods, if necessary).
      - https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-pointcuts-designators
    - @Configuration classes are proxied with CGLIB. That's how @Bean methods are intercepted. For example, for singleton bean, no matter how many times @Bean methods are called, it will return the same object.
      - Since Spring Framework 5.2, we have the option to disable proxying bean methods. If we set the _proxyBeanMethod_ attribute to *false*, Spring doesn't intercept the @Bean method calls.
        #+begin_src java
          @Configuration(proxyBeanMethods = false)
          public class ApplicationConfiguration {
          }
        #+end_src


  - Using wrong "proxyMode" will cause UnsatisfiedDependencyException

  - Proxy beans help add more behavior to the developer-defined beans


* Limitations of CGLIB proxies are:

** Requires the class of the proxied object to be non-final. Subclasses cannot be created from final classes.
** Requires methods in the proxied object to be non-final. Final methods cannot be overridden.
** Public and protected method calls on the proxy are intercepted (and even package-visible methods, if necessary).
** Does not support self-invocations. Self-invocation is where one method of the object invokes another method on the same object.
** Requires a third-party library. Not built into the Java language and thus require a library. The CGLIB library has been included into Spring, so when using the Spring framework, no additional library is required.


* Bean lifecycle

** @PostConstruct, afterPropertiesSet() from InitializingBean interface, `initMethod` property of @Bean property are called after the bean is created and dependencies are injected (@Autowired)
   - Everything in @Bean will happen before these init methods
   - Only one method should be annotated with @PostConstruct

** @PreDestroy, destroy() from DisposableBean interface, `destroyMethod` property of @Bean property are called before the bean is destroyed

** Order:
   1. @PostConstruct
   2. afterPropertiesSet() from InitializingBean interface
   3. `initMethod` property of @Bean property
   4. @PreDestroy
   5. destroy() from DisposableBean interface
   6. `destroyMethod` property of @Bean property


* BeanFactoryPostProcessor vs BeanPostProcessor (diagrams)

** BeanFactoryPostProcessor: Factory hook that allows for custom modification of an application context's _bean definitions_, adapting the bean property values of the context's underlying bean factory.

**  BeanPostProcessor: Factory hook that allows for custom modification of new _bean instances_ - for example, checking for marker interfaces or wrapping beans with proxies.
*** It is an interface that defines callback methods that allow for modification of bean instances. There are 2 methods that can be implemented:

    - postProcessBeforeInitialization(Object bean, String beanName): post-processors that populate beans via marker interfaces or the like will implement this. This is applied **before** any bean initialization callbacks (like InitializingBean's afterPropertiesSet or a custom init-method).

    - postProcessAfterInitialization(Object bean, String beanName): post-processors that wrap beans with proxies will normally implement this. This is applied **after** any bean initialization callbacks (like InitializingBean's afterPropertiesSet or a custom init-method).


* Don't couple application code with Spring infrastructure


* @Value can have $ for scalar and # for reference and #{@<bean>} for bean
  - See SpEL


* JSR 330 @Qualifier

  #+begin_src java
    package jsr330;

    import org.springframework.context.annotation.AnnotationConfigApplicationContext;
    import org.springframework.context.annotation.ComponentScan;
    import org.springframework.context.annotation.Configuration;

    import javax.annotation.PostConstruct;
    import javax.inject.Inject;
    import javax.inject.Named;
    import java.lang.annotation.ElementType;
    import java.lang.annotation.Retention;
    import java.lang.annotation.RetentionPolicy;
    import java.lang.annotation.Target;

    import static jsr330.Jsr330.Platform;

    @Configuration
    @ComponentScan
    public class Jsr330 {

        public static void main(String[] args) {
            new AnnotationConfigApplicationContext(Jsr330.class);
        }

        @Inject
        @Platform(Platform.OperatingSystems.ANDROID)
        private MarketPlace android;

        @Inject
        @Platform(Platform.OperatingSystems.IOS)
        private MarketPlace ios;

        @PostConstruct
        public void qualifyTheTweets() {
            System.out.println("ios:" + this.ios);
            System.out.println("android:" + this.android);
        }

        // the type has to be public!
        @Target({ElementType.FIELD,
                ElementType.METHOD,
                ElementType.TYPE,
                ElementType.PARAMETER})
        @Retention(RetentionPolicy.RUNTIME)
        @javax.inject.Qualifier
        public static @interface Platform {

            OperatingSystems value();

            public static enum OperatingSystems {
                IOS,
                ANDROID
            }
        }
    }

    interface MarketPlace {
    }

    @Named
    @Platform(Platform.OperatingSystems.IOS)
    class AppleMarketPlace implements MarketPlace {

        @Override
        public String toString() {
            return "apple";
        }
    }

    @Named
    @Platform(Platform.OperatingSystems.ANDROID)
    class GoogleMarketPlace implements MarketPlace {

        @Override
        public String toString() {
            return "android";
        }
    }
  #+end_src


* Gradle's 'buildscript' block determines which plugins, task classes, and other classes are available for use in the rest of the build script.
  - 'dependencies classpath' is for Gradle build script itself
  - 'dependencies compile' is for the project


* @ComponentScan and @SpringBootApplication, by default, scan the base packages and its subpackages.

** @SpringBootApplication
   - @SpringBootApplication(scanBasePackages={...})
   - @SpringBootApplication(scanBasePackageClasses={...})

** Exclude auto-configuration
   - @SpringBootApplication(exclude={DataSourceAutoConfiguration.class})
     - Alias in @EnableAutoConfiguration

   - @EnableAutoConfiguration(exclude=SecurityAutoConfiguration.class)
     - Only work for auto-configuration classes

   - property "spring.autoconfigure.exclude=DataSourceAutoConfiguration"

** Exclude beans in component scanning
   - @ComponentScan(basePackages = { "com.myapp" }, excludeFitlers = { @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE, value = Bean.class })

** Other ways to exclude beans are
   - Using @ConditionalOn...
   - Using @Profile(...)

** @ComponentScan can be used together with @Import

   #+begin_src java
     @Configuration
     @ComponentScan(basePackages =  {"com.apress.cems.repos"})
     @Import(ProdDataSourceConfig.class)
     public class RepositoryConfig {

         @Autowired
         DataSource dataSource;

         @Bean
         DetectiveRepo detectiveRepo(){
             return new JdbcDetectiveRepo(dataSource);
         }
     }
   #+end_src

** @ComponentScan needs to go together with @Configuration
  - @Import can be used without @Configuration

* @RestController: @Controller + @ResponseBody


* ApplicationContext
  - is any instance of a class implementing interface ApplicationContext
  - is a central interface to provide configuration for an application


* `@ContextConfiguration` defines class-level metadata that is used to determine how to load and configure an ApplicationContext for *Integration Tests*. (Spring framework)


* @SpringBootTest

  - Is meta annotated with `@ExtendWith(SpringExtension.class)`

  - @Sql and @SqlGroup to execute SQL scripts before or after running test methods

  - The @SpringBootTest is basically a _@ContextConfiguration_ on steroids. Under the hood, when no loader is specified (like in the @ContextConfiguration(loader = AnnotationConfigContextLoader.class) examples from previous sections, a SpringBootContextLoader loads a Spring Boot configuration from a class annotated with _@SpringBootConfiguration_ or any specialization of it, like _@SpringBootApplication_. It looks for properties on the test classpath to be injected in the _Environment_ and registers a _TestRestTemplate_ and _WebTestClient_ beans, can be used to test web applications.
  - It also provides support for different _webEnvironment_ modes, including the ability to start a fully running web server listening on a _defined or random port_.

  - _TestRestTemplate_ is used for client-side testing (wherever _RestTemplate_ is normally used in the code) and supports authentication.
  - _RestTemplate_ is not recommended for normal use in test classes.
  - _MockMvc_ can be used to mock usage of HTTP endpoints and also has methods for checking the result (server-side testing). It also features a fluent API.

  - _HttpGraphQlTester_


* @SpringBootConfiguration is a specialization of @Configuration

** @SpringBootApplication -> @SpringBootConfiguration -> @Configuration -> @Component


* @SpringBootApplication has the following meta annotations: @ComponentScan, @EnableAutoConfiguration, @SpringBootConfiguration


* @Resource(name="beanName") = @Autowired + @Qualifier


* JUnit 4
  - @RunWith(SpringJUnit4ClassRunner.class) or @RunWith(SpringRunner.class)
  - Must have @ContextConfiguration to tell the runner class where the bean definitions come from
  - @RunWith(MockitoJUnitRunner.class)


* JUnit 5
  - @ExtendWith(SpringExtension.class)
  - @SpringJUnitConfig = @ExtendWith(SpringExtension.class) + @ContextConfiguration
  - @ExtendWith(MockitoExtension.class)


* Setup Mockito
  - MockitoAnnotations.initMocks(this) in setUp() or @Before methods
  - Use runner @ExtendWith(MockitoExtension.class)


* @Transactional and @Rollback
  - By default, unit test always rollback with @Transactional
  - To disable rollback in unit tests, use @Rollback(false)
  - @Commit = @Rollback(false)

  - @Transactional has attributes "rollbackFor", "rollbackForClassName", "noRollbackFor", "noRollbackForClassName" to rollback based on thrown Exception.
    - These accepts Exception class name or object.


* By default, a transaction will be rolled back on *RuntimeException* and *Error* but not on checked exceptions (business exceptions).
  - https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/interceptor/DefaultTransactionAttribute.html#rollbackOn-java.lang.Throwable-


* Using PropertiesLoaderUtils to load property files

  #+begin_src java
    @Bean("connectionProperties")
    Properties connectionProperties(){
        try {
            return PropertiesLoaderUtils.loadProperties(
                                                        new ClassPathResource("db/prod-datasource.properties"));
        } catch (IOException e) {
            throw new ConfigurationException("Could not retrieve connection properties!", e);
        }
    }
  #+end_src


* Abstract classes and Spring
  - Abstract classes does NOT support constructor injection
    - Spring doesn't evaluate the @Autowired annotation on a constructor of an abstract class

  - Setter injections work for abstract class
    - However, we should use final keywork for the setter method so that the subclass can't override the setter method

  - Using constructor injection for required dependencies and setter injection for optional dependencies is a good rule of thumb


* There are three different ways in which you can define a Spring bean:
  - Annotating your class with the stereotype @Component annotation (or its derivatives)
    - The list of @Component derivatives includes:
      - @Service
      - @Repository
      - @Controller

  - Writing a bean factory method annotated with the @Bean annotation in a custom Java configuration class

  - Declaring a bean definition in an XML configuration file


* Aspect

** @After
   - Is executed after the advised method regardless of the outcome
** @Around
   - Is most powerful type of advice because it encapsulates the target method and has control over its execution
   - Decides whether the target method is called, and if so, when and if the result is to be returned
   - It is the only advice with the power to do this


* Entities = domain objects


* JDBC Template

** .query(...) for SELECT

** .update(...) for INSERT, UPDATE, DELETE

** .execute(...) for Data Definition Language. It can execute any arbitrary SQL,


* Transaction Management

** Add a bean of type *org.springframework.transaction.PlatformTransactionManager* in a configuration class

   #+begin_src java
     @Bean
     public PlatformTransactionManager transactionManager(){
         return new DataSourceTransactionManager(dataSource());
     }
   #+end_src

*** The DataSourceTransactionManager class is a PlatformTransactionManager implementation for *single JDBC datasources*. It binds a JDBC connection from the specified data source to the currently executing thread, potentially allowing for *one thread connection per data source*. (Source: https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#jdbc-DataSourceTransactionManager)

    - The DriverManagerDataSource class is an implementation of the standard DataSource interface that configures a plain JDBC driver through bean properties, and returns a new Connection every time. Pool-assuming Connection.close() calls will simply close the connection, so any DataSource-aware persistence code should work.
    - Spring obtains a connection to the database through a DataSource. https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#jdbc-datasource


** Add @EnableTransactionManagement on top of @Configuration class

** Annotate service methods with @Transactional
   - Methods must be public due to AOP proxies

** It is recommended and practical to annotate only concrete classes (and methods of concrete classes) with the @Transactional annotation
   - It can be used with Interface and Abstract classes as well but whether the transactional behavior is applied depends on the type of proxy created

** Use @Transactional in the service layer or the DAO/repository layer, but not both. There service layer is the usual choice, because service methods call multiple repository methods that needs to be executed in the same transaction.


* Mutitple Transaction Managers (2 ways to handle NoUniqueBeanDefinitionException)

** 1. Making configuration class annotated with @EnableTransactionManagement implement the org.springframework.transaction.annotation.TransactionManagementConfigurer interface

** 2. Add @Primary for one of the beans

** To use a specific manager, use *@Transactional(transactionManager = "specificManager")*


* Hibernate

** @MappedSuperClass: if an entity class extends a superclass, we need to mark superclass with this annotation so Hibernate knows

** @Transient: Be default, all class members are treated as persistent unless annotated with @Transient

** @Entity and @Id are mandatory for a domain class

** @Version: The version field ensures integrity when performing the merge operation and for optimistic concurrency control. To make sure that a record is handled correctly in a transactional and distributed environment, this field is mandatory.

** By default, the @Access type is AccessType.FIELD (JPA will read/write directly on the field, bypassing getters and setters)
   - You can change this by placing annotations on getters. The @Access type will become AccessType.PROPERTY


* Hibernate without JPA
  - Need to declare a SessionFactory bean

    #+begin_src java
      // Configuration

      @Bean
      public SessionFactory sessionFactory() {
          return new LocalSessionFactoryBuilder(dataSource())
              .scanPackages("com.apress.cems.dao")
              .addProperties(hibernateProperties())
              .buildSessionFactory();
      }

      @Bean
      public PlatformTransactionManager transactionManager() {
          return new HibernateTransactionManager(sessionFactory());
      }


      // Use in repository

      public HibernateRepo(SessionFactory sessionFactory) {
          this.sessionFactory = sessionFactory;
      }

      protected Session session() {
          return sessionFactory.getCurrentSession();
      }
    #+end_src


* JPA - Java Persistence API

** Components
   - Persistence Context
   - Entity Manager
   - Entity Manager Factory
   - Persistence Unit

** Setup

   #+begin_src java
     // Configuration

     @Bean
     public PlatformTransactionManager transactionManager() {
         return new JpaTransactionManager(entityManagerFactory());
     }

     @Bean
     public EntityManagerFactory entityManagerFactory() {
         LocalContainerEntityManagerFactoryBean factoryBean = new LocalContainerEntityManagerFactoryBean();
         factoryBean.setPackagesToScan("com.apress.cems.dao");
         factoryBean.setDataSource(dataSource());
         factoryBean.setJpaVendorAdapter(new HibernateJpaVendorAdapter());
         factoryBean.setJpaProperties(hibernateProperties());
         factoryBean.afterPropertiesSet();
         return factoryBean.getNativeEntityManagerFactory();
     }


     // Use in repository

     private EntityManager entityManager;

     @PersistenceContext
     void setEntityManager(EntityManager entityManager) {
         this.entityManager = entityManager;
     }
   #+end_src


* Spring Data JPA

** Reduce boiler-plate code by introducing abstract repositories

   - Simply extends JpaRepository interface and Spring will implement the interface and add data functionalities (CRUD, pagination...) at runtime (using JDK proxy).

   #+begin_src java
     public interface PersonRepo extends JpaRepository<Person, Long> {}
   #+end_src

** @Query
   - Define a custom query to execute in repository
   - Can execute both JPQL and native SQL queries
   - Queries annotated to the _@Query_ method take precedence over queries defined using _@NamedQuery_ or named queries declared in orm.xml.
   - _@NamedNativeQuery_ is used to define the query in native SQL but losing the database platform independence.
   - Use attribute "nativeQuery = true" to write native SQL
   - Spring Data JPA does not currently support dynamic sorting for native queries, because it would have to manipulate the actual query declared, which it cannot do reliably for native SQL. You can, however, use native queries for pagination by specifying the count query yourself, as shown in the following example:

     #+begin_src java
       public interface UserRepository extends JpaRepository<User, Long> {

           @Query(value = "SELECT * FROM USERS WHERE LASTNAME = ?1",
                  countQuery = "SELECT count(*) FROM USERS WHERE LASTNAME = ?1",
                  nativeQuery = true)
                  Page<User> findByLastname(String lastname, Pageable pageable);
       }
     #+end_src

** Add "@EnableJpaRepositories(basePackages = {"com.apress.cems.dj.repos"})" with @Configuration

   - In case with multiple "entityManagerFactory" and multiple persistence contexts, specify "entityManagerFactoryRef" and "transactionManagerRef":

     #+begin_src java
       @EnableJpaRepositories(basePackages = {"com.apress.cems.dj.repos2"},
                              entityManagerFactoryRef = "secondEntityManagerFactory",
                              transactionManagerRef = "secondTransactionManager")
     #+end_src

** Setup

   #+begin_src java
     @Bean
     public LocalContainerEntityManagerFactoryBean entityManagerFactory(){
         LocalContainerEntityManagerFactoryBean factoryBean = new LocalContainerEntityManagerFactoryBean();
         factoryBean.setDataSource(dataSource);
         factoryBean.setPackagesToScan("com.apress.cems.dao");

         JpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter();
         factoryBean.setJpaVendorAdapter(vendorAdapter);
         factoryBean.setJpaProperties(hibernateProperties);
         return factoryBean;
     }

     @Bean
     public PlatformTransactionManager transactionManager(EntityManagerFactory emf){
         return new JpaTransactionManager(emf);
     }

     @Bean
     public PersistenceExceptionTranslationPostProcessor exceptionTranslation(){
         return new PersistenceExceptionTranslationPostProcessor();
     }
   #+end_src

*** With PersistenceUnitManager

    #+begin_src java
     @Bean
     public EntityManagerFactory entityManagerFactory(){
         LocalContainerEntityManagerFactoryBean factoryBean = new LocalContainerEntityManagerFactoryBean();
         factoryBean.setPersistenceUnitManager(persistenceUnitManager());
         factoryBean.setJpaVendorAdapter(new HibernateJpaVendorAdapter());
         factoryBean.setJpaProperties(hibernateProperties());
         factoryBean.afterPropertiesSet();
         factoryBean.setLoadTimeWeaver(new InstrumentationLoadTimeWeaver());
         return factoryBean.getNativeEntityManagerFactory();
     }

     @Bean
     public PlatformTransactionManager transactionManager(){
         return new JpaTransactionManager(entityManagerFactory());
     }

     @Bean
     public PersistenceExceptionTranslationPostProcessor exceptionTranslation(){
         return new PersistenceExceptionTranslationPostProcessor();
     }

     @Bean
     public PersistenceUnitManager persistenceUnitManager(){
         MergingPersistenceUnitManager persistenceUnitManager = new MergingPersistenceUnitManager();
         persistenceUnitManager.setPackagesToScan("com.apress.cems.dao");
         persistenceUnitManager.setDefaultDataSource(dataSource());
         return persistenceUnitManager;
     }
    #+end_src

** How Spring Data JPA repository is implemented:
   - There's no code generation going on, which means: no CGLib, no byte-code generation at all. The fundamental approach is that a JDK proxy instance is created programmatically using Spring's ProxyFactory API to back the interface and a MethodInterceptor intercepts all calls to the instance and routes the method into the appropriate places.
   - https://stackoverflow.com/questions/38509882/how-are-spring-data-repositories-actually-implemented/38511337#38511337


* Embedded databases are HSQLDB, H2 and DERBY.
  - spring.jpa.hibernate.ddl-auto defaults to "none" for non-embedded databases such as Oracle, MySQL, Postgres...
  - It defaults to "create-drop" for HSQLDB, H2 and DERBY.


* Spring Data Access Exception

  - _org.springframework.dao.DataAccessException_ is the Root of the hierarchy of data access exceptions in Spring Framework.
  - There are NonTransientDataAccessException, RecoverableDataAccessException and TransientDataAccessException under it.

  - It helps convert proprietary, checked exceptions (e.g. Hibernate) to a set of focused runtime exceptions.
  - This allows one to switch between the aforementioned persistence technologies fairly easily and it also allows one to code without worrying about catching exceptions that are specific to each technology.
  - These exceptions wrap the original exception so there is never any risk that one might lose any information as to what might have gone wrong.


* Spring Boot JPA

** No need for configuration.
** Have `spring-boot-starter-data-jpa` on classpath and add approriate properties in `application.yml`
** Ref: https://spring.io/guides/gs/managing-transactions/

* JDBCTemplate

  - RowMapper<T>
    - When each row of the ResultSet maps to a domain object
    - Stateless and reusable
    - Per-row basis

  - RowCallbackHandler
    - When no value should be returned
    - Typically stateful
    - Per-row basis

  - ResultSetExtractor<T>
    - When multiple rows, or multiple records from different tables returned in a ResultSet map to a single object
    - Typically stateless and reusable
    - Can access the whole ResultSet


* Servlet (Interface)
  - A servlet is a small Java program that runs within a Web server. Servlets receive and respond to requests from Web clients, usually across HTTP, the HyperText Transfer Protocol.

** javax.servlet.ServletRequest (javax.servlet.http.HttpServletRequest) to access request details: headers, request, and session attributes

** javax.servlet.ServletResponse (javax.servlet.http.HttpServletResponse) to enrich the response with new headers and attributes before being sent to the user


* DispatchServlet configuration

** Add @EnableWebMvc in @Configuration class

** Has @Configuration class implement WebMvcConfigurer interface (this interface replaces WebMvcConfigurerAdapter class)

** DefaultServletHttpRequestHandler is typically configured with a URL mapping of "/*" and the lowest priority relative to all others URL mappings and its sole responsiblity it to serve static resources

** DispatcherServlet has 2 WebApplicationContext: Servlet Web Application Context (DispatcherServletContext) and Root Application Context
   - Servlet Web Application Context inherits all the beans already defined in the Root Application Context.
   - Root Application Context contains all non-web beans (services, datasources, repositories...) and is instantiated using a bean of type _org.springframework.web.context.ContextLoaderListener_.
   - https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-servlet-context-hierarchy

* Default Exception Handler

  #+begin_src java
    // Declare implementation for SimpleMappingExceptionResolver
    public class MissingExceptionResolver extends SimpleMappingExceptionResolver {
        @Override
        protected ModelAndView doResolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {
            if (ex instanceof NoHandlerFoundException) {
                ModelAndView model = new ModelAndView("error");
                model.addObject("problem","URL not supported : " + request.getRequestURI());
                response.setStatus(HttpStatus.NOT_FOUND.value());
                return model;
            }
            return null;
        }
    }

    // Set this exception resolver with the lowest priority, so that every time something goes wrong with the application, this exception resolver will be used first
    @Bean
    SimpleMappingExceptionResolver simpleMappingExceptionResolver(){
        var resolver = new MissingExceptionResolver();
        resolver.setOrder(Ordered.HIGHEST_PRECEDENCE);
        return resolver;
    }
  #+end_src


* Security

** AuthenticatedVoter class will vote if an attribute of IS_AUTHENTICATED_FULLY or IS_AUTHENTICATED_REMEMBERED or IS_AUTHENTICATED_ANONYMOUSLY is present.

** The default name of the spring security filter that is applied to all requests in a secured Spring web application: springSecurityFilterChain.

** Using ant or mvc matchers to secure URLs is more secure than using tablibs.
   - tablibs can hide a URL but if the user enters the link manually in the browser, the view will shown to the user, regardless of its role.
   - We need to set the restriction in the configuration class as well using ant or mvc matchers.

** To enable Method Security, add @EnableGlobalMethodSecurity(secureEnabled = true) on a Configuration class and add @Secured("<ROLE>") on the target method.
   - It causes the class containing the method to be wrapped in a secure proxy (AOP) to restrict access only to users with certain <ROLE>


* Gradle

  - The _compile_ and _runtime_ configurations have been removed with Gradle 7.0. Please refer to the upgrade guide how to migrate to _implementation_ and _api_ configurations.
  - If you want to expose dependencies use _api_ or _compile_.
  - If you don't want to expose dependencies (hiding your internal module) then use _implementation_.


* Spring REST

  - HTTP verbs are used as actions to execute on the resources (GET, PUT, PATCH, POST, DELETE, HEAD, and OPTIONS).
  - GET is safe and idempotent  (read-only). PUT and DELETE are not safe but generally idempotent.
  - POST is neither safe nor idempotent.


* RestTemplate

** RestTemplate is thread-safe so it can access any number of services in different parts of an application.

** Use `restTemplate.exchange(...)` to test the response status code. It returns ResponseEntity object.

** `restTemplate.put(...)` and `restTemplate.delete(...)` return void.

** *ForEntity methods return ResponseEntity objects. These contain the response status code as well as the object in the payload.

** *ForObject methods do not return the HTTP status code.

** ObjectFactory is not used as an argument in any method of RestTemplate.

** @RequestParam is used to map query parameter. It is required by default. It can be changed by swiching `required` attribute.

** @PathVariable is used to map path parameter.

** Supported methods:

*** GET
    - getForObject: Retrieves a representation via GET.
    - getForEntity: Retrieves a ResponseEntity (that is, status, headers, and body) by using GET.

*** HEAD
    - headForHeaders: Retrieves all headers for a resource by using HEAD.

*** POST
    - postForLocation: Creates a new resource by using POST and returns the Location header from the response.
    - postForObject: Creates a new resource by using POST and returns the representation from the response.
    - postForEntity: Creates a new resource by using POST and returns the representation from the response.

*** PUT
    - put: Creates or updates a resource by using PUT.

*** PATCH
    - patchForObject: Updates a resource by using PATCH and returns the representation from the response. Note that the JDK HttpURLConnection does not support PATCH, but Apache HttpComponents and others do.

*** DELETE
    - delete: Deletes the resources at the specified URI by using DELETE.

*** OPTIONS
    - optionsForAllow: Retrieves allowed HTTP methods for a resource by using ALLOW.

*** Others (everything can be handled by these)
    - exchange: More generalized (and less opinionated) version of the preceding methods that provides extra flexibility when needed. It accepts a RequestEntity (including HTTP method, URL, headers, and body as input) and returns a ResponseEntity. These methods allow the use of ParameterizedTypeReference instead of Class to specify a response type with generics.
    - execute: The most generalized way to perform a request, with full control over request preparation and response extraction through callback interfaces.


* @MockBean

** We can use the @MockBean to add mock objects to the Spring application context. The mock will replace any existing bean of the same type in the application context.

* Spring Web Test

** @WebMvcTest
   - Mock specific controller:

     #+begin_src java
       @WebMvcTest(controllers = {MultiplePersonController.class})
       class SpringBootWebApplicationTest {

           private MockMvc mockMvc;

           @MockBean
           private PersonService mockService;

           @Autowired
           private WebApplicationContext webApplicationContext;

           @BeforeEach
           void setUp() throws Exception {
               mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build();
               // OR
               mockMvc = MockMvcBuilders.standaloneSetup(new MultiplePersonController(...)).build();
           }

           // ...
       }
     #+end_src

   @WebMvcTest(controllers = {MultiplePersonController.class})
   - This annotation is the one to use when a test focuses only on Spring MVC components because it has the effect of *DISABLING* full autoconfiguration and registers configurations only relevant to MVC components; classes annotated with @Controller or @ControllerAdvice and classes implementing WebMvcConfigurer, but not @Service, @Repository, and so forth.
   - https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#features.testing.spring-boot-applications.spring-mvc-tests
   - MockMvc object can be injected with mock Services.
   - It can be used together with *@MockBean* to mock dependencies required by controllers being tested.
   - It can be used together with *@WithMockUser* to test controllers that are part of an application secured with basic authentication.

** @AutoConfigureMockMvc + @SpringBootTest
   - Can be used with @SpringBootTest to bootstrp the full application context
   - MockMvc object will be automatically configured with full context

** @SpringBootTest alone
   - Bootstrap the full Spring Boot context to tests to be run in. This annotation is specific to integration tests.
   - Web application context is not mocked. It runs like a real server.

*** Options of webEnvironment
    - @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT): a server is started at random port, good for parallel testing
      - When using an embedded Web server, setting _server.port=0_ makes Spring search for a random unassigned port to use.
    - @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.MOCK)
    - @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)
    - @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.NONE)

** Custom ports
   - @LocalServerPort
   - @Value("${local.management.port}")


* Spring Data JPA

** Declare an instant repository
   - Have an repo interface extends the Repository interface
   - Have an repo interface extends the CrudRepository interface (for CRUD operations out of the box)
   - Have an repo interface extends the PagingAndSortingRepository interface (for CRUD operations + entity pagination out of the box)
   - Have an repo interface extends the JpaRepository interface (for multiple methods out of the box + CRUD + PagingAndSorting)
   - Have @RepositoryDefinition on top of repo interface (for decoupling from Spring components)


* Spring bean scopes

  |-------------+-------------------------------------------------+--------------------------------------------------------------------------------------------|
  | Scope       | Annotation                                      | Description                                                                                |
  |-------------+-------------------------------------------------+--------------------------------------------------------------------------------------------|
  | singleton   | none                                            | The Spring IoC creates a single instance of this bean, and any request for beans with      |
  |             | @Scope("singleton")                             | a name (or aliases) matching this bean definition results in this instance being returned. |
  |             | @Scope(ConfigurableBeanFactory.SCOPE_SINGLETON) |                                                                                            |
  |-------------+-------------------------------------------------+--------------------------------------------------------------------------------------------|
  | prototype   | @Scope("prototype")                             | Every time a request is made for this specific                                             |
  |             | @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) | bean, the Spring IoC creates a new instance.                                               |
  |-------------+-------------------------------------------------+--------------------------------------------------------------------------------------------|
  | thread      | @Scope("thread")                                | Introduced in Spring 3.0, it is available, but                                             |
  |             |                                                 | not registered by default, so the developer                                                |
  |             |                                                 | must explicitly register it in the same way as                                             |
  |             |                                                 | if a custom scope would be defined.                                                        |
  |-------------+-------------------------------------------------+--------------------------------------------------------------------------------------------|
  | request     | @Scope("request")                               | The Spring IoC creates a bean instance for                                                 |
  |             | @RequestScope                                   | each HTTP request. Only valid in the context                                               |
  |             | @Scope(WebApplicationContext.SCOPE_REQUEST)     | of a web-aware Spring ApplicationContext.                                                  |
  |-------------+-------------------------------------------------+--------------------------------------------------------------------------------------------|
  | session     | @Scope("session")                               | The Spring IoC creates a bean instance for                                                 |
  |             | @SessionScope                                   | each HTTP session. Only valid in the context                                               |
  |             | @Scope(WebApplicationContext.SCOPE_SESSION)     | of a web-aware Spring ApplicationContext.                                                  |
  |-------------+-------------------------------------------------+--------------------------------------------------------------------------------------------|
  | application | @Scope("application")                           | The Spring IoC creates a bean                                                              |
  |             | @ApplicationScope                               | for the global application context. Only                                                   |
  |             | @Scope(WebApplicationContext.SCOPE_APPLICATION) | valid in the context of a web-aware Spring                                                 |
  |             |                                                 | ApplicationContext.                                                                        |
  |-------------+-------------------------------------------------+--------------------------------------------------------------------------------------------|
  | websocket   | @Scope("websocket")                             | The Spring IoC creates a bean instance                                                     |
  |             |                                                 | for the scope of a WebSocket. Only valid                                                   |
  |             |                                                 | in the context of a web-aware Spring ApplicationContext.                                   |
  |-------------+-------------------------------------------------+--------------------------------------------------------------------------------------------|

  - If bean A is singleton, and it has a property bean B which is a non-singleton, every time bean A is acquired by a client, the same instance of bean B is supplied.
    - Use _@Lookup_ annotation to inject prototype-scoped bean into a singleton bean.

  - As a rule, use the prototype scope for all stateful beans and the singleton scope for stateless beans.

  - In contrast to the other scopes, Spring does not manage the complete lifecycle of a PROTOTYPE bean: the container instantiates, configures, and otherwise assembles a prototype object, and hands it to the client, with no further record of that prototype instance. Thus, although initialization lifecycle callback methods are called on all objects regardless of scope, in the case of prototypes, configured destruction lifecycle callbacks are not called. The client code must clean up prototype-scoped objects and release expensive resources that the prototype bean(s) are holding. In some respects, the Spring containerâ€™s role in regard to a prototype-scoped bean is a replacement for the Java new operator. All lifecycle management past that point must be handled by the client. https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-prototype


* Spring provides the following mock objects to use in tests:
** Environment
** JNDI
** Servlet API


* Sterotype annotations:
** Component
** Service
** Repository
** Controller
** Indexed


* Cross-cutting concerns for an Enterprise Application:
** Security
** Caching
** Logging
** Monitoring
** Data validation
** Internationalization
** Error detection and correction. Exception handling.
** Memory management
** Synchronization
** Connecting to the database (connection pooling, reusing connections, open and close connections)
** Transaction


* Transaction

** Declarative usage
   - @Transactional

** Programmatic usage
   - TransactionTemplate class
   - Explicitly setting the transaction name is something that can only be done programmatically

** Local Transaction
   - Local transactions are resource-specific, such as a transaction associated with a JDBC connection. Local transactions may be easier to use, but have significant disadvantages: they cannot work across multiple transactional resources.

** Global Transaction
   - Global transactions enable you to work with multiple transactional resources, typically relational databases and message queues. For an Example, sending money from one bank to an another bank is a Global Transaction. Two banks work with two different resources like databases and the transaction takes place between them. Such a transaction is called as a Global Transaction.

** Spring offers a consistent programming model across different transaction APIs, such as Java Transaction API (JTA), JDO (Java Data Objects), JDBC, Hibernate, and the Java Persistence API (JPA).


* Spring Web jars

** spring-web.jar
   - @RestController, @ResponseBody, @RequestBody, @PathVariable, @RequestParam are present in the spring-web module.
   - From `org.springframework:spring-web` dependency

** spring-webmvc.jar
   - This is where DispatchServlet class lives.
   - From `org.springframework:spring-webmvc` dependency

*** Spring MVC supports a variety of templating technologies, including Thymeleaf, FreeMarker, Mustache, and JSPs.

** They both are in `org.springframework.boot:spring-boot-starter-web`


* Spring Boot default logging support

  - Spring Boot uses Commons Logging for all internal logging but leaves the underlying log implementation open.
  - Default configurations are provided for _Java Util Logging_, _Log4J2_, and _Logback_.
  - The default logging level is INFO.


* Allow bean definition overriding in Spring Boot (due to  name conflicts...)

** spring.main.allow-bean-definition-overriding=true


* Actuator

** Allow all end points:
   - `management.endpoints.web.exposure.include=*`
   - `management.endpoints.enabled-by-default=true/false` # Whether to enable or disable all endpoints by default.

** Exclude specific end points: `management.endpoints.web.exposure.exclude=env,beans`

** Default HEATLH INDICATOR statuses: UP, DOWN, OUT_OF_SERVICE, UNKNOWN

** Endpoints

   - auditevents
   - beans
   - caches
   - conditions
   - configprops
   - env
   - flyway
   - health
   - httptrace
   - info
   - integrationgraph
   - loggers
   - liquibase
   - metrics
   - mappings
   - quartz
   - scheduledtasks
   - sessions
   - shutdown
   - startup
   - threaddump

*** Additional endpoints for web applications

    - heapdump
    - jolokia
    - logfile
    - prometheus

** Health Indicators
   - cassandra: CassandraDriverHealthIndicator
   - couchbase: CouchbaseHealthIndicator
   - db: DataSourceHealthIndicator
   - diskspace: DiskSpaceHealthIndicator
   - elasticsearch: ElasticsearchRestHealthIndicator
   - hazelcast: HazelcastHealthIndicator
   - influxdb: InfluxDbHealthIndicator
   - jms: JmsHealthIndicator
   - ldap: LdapHealthIndicator
   - mail: MailHealthIndicator
   - mongo: MongoHealthIndicator
   - neo4j: Neo4jHealthIndicator
   - ping: PingHealthIndicator
   - rabbit: RabbitHealthIndicator
   - redis: RedisHealthIndicator
   - solr: SolrHealthIndicator

*** Status severity order can be changed with the property: management.health.status.order

** Metrics
*** JVM Metrics
*** System Metrics
*** Application Startup Metrics
*** Logger Metrics


** Auditing can be enabled by providing a bean of type _AuditEventRepository_ in your applicationâ€™s configuration.

** Configuration Properties relating to actuator are all under the key "management". For example: _management.auditevents.enabled = true_


* Custom Actuator endpoint

** @EndPoint for both JMX and HTTP
** @JmxEndpoint for JMX
** @WebEndpoint for HTTP

** /info and /health are default endpoints (/actuator is not an endpoint)


* Spring Security

** Spring Security offers the following authentication mechanisms:
*** Username and Password
*** OAuth 2.0
*** SAML 2.0
*** CAS
*** Remember Me
*** JAAS Authentication
*** OpenID
*** Pre-Authentication Scenarios
*** X509 Authentication

** Configure security
   - @EnableWebSecurity on Configuration class
   - Have @Configuration class extends "WebSecurityConfigurerAdapter"
   - Override "configure(WebSecurity web)" to specify resources that Spring Security should be ignoring, like style files and images.
   - Override "configure(HttpSecurity http)" to filter URL with "antMatchers(...)" or "mvcMatchers(...)"
   - The antMatcher(...) method is the equivalent of the <intercept-url.../> element from XML.

*** <intercept-url> Attribute (https://docs.spring.io/spring-security/site/docs/3.2.5.RELEASE/reference/htmlsingle/#nsa-intercept-url)

    - _access_: Lists the access attributes which will be stored in the FilterInvocationSecurityMetadataSource for the defined URL pattern/method combination. This should be a comma-separated list of the security configuration attributes (such as role names).
      - Examples (https://docs.spring.io/spring-security/site/docs/3.2.5.RELEASE/reference/htmlsingle/#jc-httpsecurity):

        #+begin_src java
          /**
              Ensures that any request to our application requires the user to be authenticated

              Allows users to authenticate with form based login

              Allows users to authenticate with HTTP Basic authentication
           ,*/
          protected void configure(HttpSecurity http) throws Exception {
              http
                  .authorizeRequests()
                  .anyRequest().authenticated()
                  .and()
                  .formLogin()
                  .and()
                  .httpBasic();
          }
        #+end_src

      - Equivalent XML configuration:

        #+begin_src xml
          <http use-expressions="true">
            <intercept-url pattern="/**" access="authenticated"/>
            <form-login />
            <http-basic />
          </http>
        #+end_src

      - Other examples:

        #+begin_src xml
          <http>
            <intercept-url pattern="/login.jsp*" access="IS_AUTHENTICATED_ANONYMOUSLY"/>
            <intercept-url pattern="/**" access="ROLE_USER" />
            <form-login login-page='/login.jsp'/>
          </http>
        #+end_src

    - _filters_: Can only take the value "none". This will cause any matching request to bypass the Spring Security filter chain entirely. None of the rest of the <http> configuration will have any effect on the request and there will be no security context available for its duration. Access to secured methods during the request will fail.

    - _method_: The HTTP Method which will be used in combination with the pattern to match an incoming request. If omitted, any method will match. If an identical pattern is specified with and without a method, the method-specific match will take precedence.

    - _pattern_: The pattern which defines the URL path. The content will depend on the request-matcher attribute from the containing http element, so will default to ant path syntax.

    - _requires-channel_: Can be "http" or "https" depending on whether a particular URL pattern should be accessed over HTTP or HTTPS respectively. Alternatively the value "any" can be used when there is no preference. If this attribute is present on any <intercept-url> element, then a ChannelProcessingFilter will be added to the filter stack and its additional dependencies added to the application context.


** Enable method security: `@EnableGlobalMethodSecurity(securedEnabled = true)`
   - @Secured is usually used in Service class
   - Spring Security will wrap the service class in a secure proxy

*** Secured Method annotations:
**** Supports SpEL expression (recommended in new applications): @PreAuthorize, @Prefilter, @PostAuthorize, @PostFilter
**** Not Support SpEL espression: @Secured (securedEnabled = true), @RolesAllowed (jsr250Enabled = true)

** Concepts

   - _GrantedAuthority_ Object contains the information related to authority or roles, scopes, etc. assigned to the authenticated user (principal).

   - _UserDetailsService_ retrieves the information from a database into _UserDetails_ object. Based on the implementation used, the information may be stored in a database, in memory or elsewhere if the custom implementation is used.

   - _UserDetails_ object holds the information of user like username, password, authorities. This information is used to create an Authenticated Object.

   - _Authentication_ object represents the token for authentication request after the request has been granted.


   - *All* the requests are handled by _DelegatingFilterProxy_ and it sends the request to _FilterChainProxy_ for handling further Authentication flow.

   - _DelegatingFitlerProxy_ is a bridge between Servlet container's life cycle and Spring's ApplicationContext
     - DelegatingFilterProxy is a Servlet Filter. _Servlet Filters_ are executed just before the servlets are executed. So any security mechanism like authentication are implemented using filters, so that a valid user is accessing the secured resource.

   - _DelegatingFilterProxy_ can be registered via standard Servlet container mechanisms, but delegate all the work to a Spring Bean that implements Filter (_FilterChainProxy_).

   - _FilterChainProxy_ is a special Filter provided by Spring Security that allows delegating to many Filter instances through _SecurityFilterChain_.

   - _SecurityFilterChain_ associates a request URL pattern with a list of filters.
     - Filters under `SecurityFilterChain` are `GenericFilterBeans`, which are Spring `Filters`. These are also `Servlet Filters`, but have Spring implementation.

** Security Taglibs (https://docs.spring.io/spring-security/site/docs/5.0.7.RELEASE/reference/html/taglibs.html#taglibs-authorize)

   - Check whether user has certain role: <sec:authorize access="hasRole('supervisor')">
     - Expression-Based Access Control: https://docs.spring.io/spring-security/reference/servlet/authorization/expression-based.html#el-common-built-in

   - Retrieve the roles of authenticated user: <sec:authentication property="principal.authorities" />

   - Access current Authenication object (which includes principal property): <sec:authentication property="principal.username" />

** Support PasswordEncoder and Salt and Hash...


* Spring Boot default embedded containers:

  - For servlet stack applications, the _spring-boot-starter-web_ includes Tomcat by including _spring-boot-starter-tomcat_, but you can use _spring-boot-starter-jetty_ or _spring-boot-starter-undertow_ instead.

  - For reactive stack applications, the spring-boot-starter-webflux includes Reactor Netty by including spring-boot-starter-reactor-netty, but you can use spring-boot-starter-tomcat, spring-boot-starter-jetty, or spring-boot-starter-undertow instead.


* spring.factories file

  - Locate auto-configuration candidates in, for instance, your own starter module.
  - Activate application listeners that creates a file containing the application process id and/or creates file(s) containing the port number(s) used by the running web server (if any). These listeners, ApplicationPidFileWriter and WebServerPortFileWriter, both implement the ApplicationListener interface.
  - Register application event listeners regardless of how the Spring Boot application is created (configured). Implement a class that inherits from SpringApplicationEvent and register it in the spring.factories file.
  - Register a filter to limit the auto-configuration classes considered. See AutoConfigurationImportFilter.
  - Register failure analyzers. Failure analyzers implement the FailureAnalyzer interface and can be registered in the spring.factories file.
  - Register the availability of view template providers. See the TemplateAvailabilityProvider interface.
  - Customize the environment or application context prior to the Spring Boot application has started up. Classes that implementing the ApplicationListener, ApplicationContextListener or the EnvironmentPostProcessor interfaces may be registered in the spring.factories file.

  - https://github.com/spring-projects/spring-boot/blob/main/spring-boot-project/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories


* @TestConfiguration

  - The @TestConfiguration annotation inherits from the @Configuration annotation, the main difference is that @TestConfiguration is excluded during Spring Bootâ€™s component scanning.
  - Configuration classes annotated with @TestConfiguration are excluded from component scanning, so we need to IMPORT them explicitly in every test where we want to autowire them.


* HttpMessageConverter implementations

** AtomFeedHttpMessageConverter - Converts to/from Atom feeds.
** ByteArrayHttpMessageConverter - Converts to/from byte arrays.
** FormHttpMessageConverter - Converts to/from HTML forms.
** Jaxb2RootElementHttpMessageConverter - Reads classes annotated with the JAXB2 annotations @XmlRootElement and @XmlType and writes classes annotated with @XmlRootElement.
** MappingJackson2HttpMessageConverter - Converts to/from JSON using Jackson 2.x.


* Transaction Isolation

  |------------------+-------------+----------------------+---------------|
  |                  | dirty reads | non-repeatable reads | phantom reads |
  |------------------+-------------+----------------------+---------------|
  | READ_UNCOMMITTED | yes         | yes                  | yes           |
  | READ_COMMITTED   | no          | yes                  | yes           |
  | REPEATABLE_READ  | no          | no                   | yes           |
  | SERIALIZABLE     | no          | no                   | no            |
  |------------------+-------------+----------------------+---------------|


* Transaction Propagation

  |---------------+------------------------------------------+--------------------------+---------------------|
  |               | reuse the existing transaction           | create a new transaction | require transaction |
  |---------------+------------------------------------------+--------------------------+---------------------|
  | REQUIRED      | yes                                      | yes                      | yes                 |
  | NESTED        | yes - create a nested one                | yes                      | yes                 |
  | MANDATORY     | yes - throw and exception if none exists | no                       | yes                 |
  | REQUIRES_NEW  | no  - suspend the current one            | yes                      | yes                 |
  | SUPPORTS      | yes                                      | no                       | no                  |
  | NOT_SUPPORTED | no  - suspend the current one            | no                       | no                  |
  | NEVER         | no  - throw an exception if one exists   | no                       | no                  |
  |---------------+------------------------------------------+--------------------------+---------------------|


* Profile

** @Profile({"p1", "!p2"}), registration will occur if profile 'p1' is active OR if profile 'p2' is not active.

** @Profile({"p1", "p2"}), that class will not be registered or processed unless at least profile 'p1' OR 'p2' has been activated.


* API vs. SPI
** An application programming interface (API) describes what a class/method does; a Service Provider Interface (SPI) describes what you need to extend and implement.


* AOP Terminology
** _Aspect_ : A class containing code specific to a cross-cutting concern. A class declaration is recognized in Spring as an aspect if it is annotated with the @Aspect annotation.

** _Weaving_ : A synonym for this word is interlacing, but in software the synonym is linking and it refers to aspects being combined with other types of objects to create an advised object. This can be done at compile time (using the AspectJ compiler, for example), load time, or at runtime. Spring AOP, like other pure Java AOP frameworks, performs weaving at _runtime_.

** _Join Point_ : A point during the execution of a program, such as the execution of a method or the handling of an exception. I. In Spring AOP, a join point is *always* a method execution. Basically, the join point marks the execution point where aspect behavior and target behavior join.

** _Target object_ : An object to which the aspect applies.

** _Target method_ : the advised method.

** _Advice_ : The action taken by an aspect at a join point. In Spring AOP, there are multiple advice types.
*** â€‹@Before advice: Methods annotated with @Before that will execute before the join point. These methods do not prevent the execution of the target method unless they throw an exception.
*** â€‹@AfterReturning advice: Methods annotated with @AfterReturning that will execute after a join point completes normally, meaning that the target method returns normally without throwing an exception.
*** â€‹@AfterThrowing advice: Methods annotated with @AfterThrowing that will execute after a join point execution ends by throwing an exception.
*** â€‹@After (finally) advice: Methods annotated with @After that will execute after a join point execution, no matter how the execution ended.
*** â€‹@Around advice: Methods annotated with @Around intercept the target method and surround the join point. This is the most powerful type of advice since can perform custom behavior before and after the invocation. It has the responsibility of choosing to perform the invocation or return its own value, and it provides the option of stopping the propagation of an exception.

** _Pointcut_ : A predicate used to identify join points. Advice definitions are associated with a pointcut expression and the advice will execute on any join point matching the pointcut expression. Pointcut expressions are defined using AspectJ Pointcut Expression Language3 Pointcut expressions can be defined as arguments for Advice annotations or as arguments for the @Pointcut annotation.

** _Introduction_: Declaring additional methods, fields, interfaces being implemented, and annotations on behalf of another type. Spring AOP allows this using a suite of AspectJ @Declare* annotations that are part of the aspectjrt library.

** _AOP proxy_: The object created by AOP to implement the aspect contracts. In Spring proxy objects can be JDK dynamic proxies or CGLIB proxies. By default, the proxy objects are JDK dynamic proxies, and the object being proxied must implement an interface that is also implemented by the proxy object. But a library like CGLIB can create proxies by subclassing, so an interface is not needed.


* AOP annotation

** Advice: @Before, @AfterReturning, @AfterThrowing, @After, @Around

** Pointcut epxression:
*** For Type matching: execution, within, this, target, args
*** For Annotation matching: @annotation, @target, @args, @within




* AOP
** @EnableAspectJAutoProxy
** @EnableAspectJAutoProxy(proxyTargetClass = true)
** Local calls within the target object cannot be intercepted

** For those not familiar with AOP, the key point to understand is that Spring Security can help you protect method invocations as well as web requests. Most people are interested in securing method invocations on their services layer. This is because the services layer is where most business logic resides in current-generation Java EE applications. If you just need to secure method invocations in the services layer, Springâ€™s standard AOP will be adequate. If you need to secure domain objects directly, you will likely find that AspectJ is worth considering.

** Declaring additional methods or fields on behalf of a type. Spring AOP allows you to introduce new interfaces (and a corresponding implementation) to any advised object. For example, you could use an introduction to make a bean implement an IsModified interface, to simplify caching. (An introduction is known as an inter-type declaration in the AspectJ community.): https://stackoverflow.com/a/61555095

** Spring AOP cannot use JDK dynamic proxies on target objects that does not implement any interface. Spring AOP can use CGLIB proxies on target objects that does not implement any interface. It will subclass the target class. In Spring AOP, if the target object implements an interface, it defaults to using the standard JDK dynamic proxies, and this behavior can be overridden to force the use CGLIB instead. Spring AOP performs weaving at runtime.


* Auto-configuration condition annotations:

** @ConditionalOnClass - Presence of class on classpath.
** @ConditionalOnMissingClass - Absence of class on classpath.
** @ConditionalOnBean - Presence of Spring bean or bean type (class).
** @ConditionalOnMissingBean - Absence of Spring bean or bean type (class).
** @ConditionalOnProperty - Presence of Spring environment property.
** @ConditionalOnResource - Presence of resource such as file.
** @ConditionalOnWebApplication - If the application is considered to be a web application, that is uses the Spring WebApplicationContext, defines a session scope or has a StandardServletEnvironment.
** @ConditionalOnNotWebApplication - If the application is not considered to be a web application.
** @ConditionalOnExpression - Bean or configuration active based on the evaluation of a SpEL expression.
** @ConditionalOnCloudPlatform - If specified cloud platform, Cloud Foundry, Heroku or SAP, is active.
** @ConditionalOnEnabledEndpoint - Specified endpoint is enabled.
** @ConditionalOnEnabledHealthIndicator - Named health indicator is enabled.
** @ConditionalOnEnabledInfoContributor - Named info contributor is enabled.
** @ConditionalOnEnabledResourceChain - Spring resource handling chain is enabled.
** @ConditionalOnInitializedRestarter - Spring DevTools RestartInitializer has been applied with non-null URLs.
** @ConditionalOnJava - Presence of a JVM of a certain version or within Condition Annotation Condition Factor a version range.
** @ConditionalOnJndi - Availability of JNDI InitialContext and specified JNDI locations exist.
** @ConditionalOnManagementPort - Spring Boot Actuator management port is either: Different from server port, same as server port or disabled.
** @ConditionalOnRepositoryType - Specified type of Spring Data repository has been enabled.
** @ConditionalOnSingleCandidate - Spring bean of specified type (class) contained in bean factory and single candidate can be determined.


* mvcMatcher() vs antMatcher()
  - Generally mvcMatcher() is more secure than an antMatcher().
  - mcvMatcher() matches a file extension (such as .html or .css).

  - Example 1:
    - antMatchers("/secured") matches only the exact /secured URL
    - mvcMatchers("/secured") matches /secured as well as /secured.html, /secured.xyz, /securedâ€‹/
  - Example 2:
    - antMatchers("/users/**") matches any path starting with /users
    - antMatchers("/users") matches only the exact /users URL
    - mvcMatchers("/users") matches /users, /usersâ€‹/, /users.html
    - mvcMatchers("/*/users") matches /hr/users, /hr/users.html, /management/users, /management/users.html


* Type-safe Configuration Properties

  - Using the @Value("${property}") annotation to inject configuration properties can sometimes be cumbersome, especially if you are working with multiple properties or your data is hierarchical in nature. Spring Boot provides an alternative method of working with properties that lets strongly typed beans govern and validate the configuration of your application.

  - https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.typesafe-configuration-properties

  - @ConfigurationProperties vs. @Value
    |-------------------+--------------------------+--------------------------|
    | Feature           | @ConfigurationProperties | @Value                   |
    |-------------------+--------------------------+--------------------------|
    | Relaxed binding   | Yes                      | Limited (see note below) |
    | Meta-data support | Yes                      | No                       |
    | SpEL evaluation   | No                       | Yes                      |
    |-------------------+--------------------------+--------------------------|


* Spring Web MVC
** Definition:
    - Model: It is usually prepared inside controller methods, and it carries information that the view needs to create the view output.
    
** Method Arguments
   - https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-arguments

** Method Return Values
   - https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-return-types

** Spring MVC Auto-configuration

   Spring Boot provides auto-configuration for Spring MVC that works well with most applications.

   The auto-configuration adds the following features on top of Springâ€™s defaults:

   - Inclusion of _ContentNegotiatingViewResolver_ and _BeanNameViewResolver_ beans.

   - Support for serving static resources, including support for _WebJars_.

   - Automatic registration of _Converter_, _GenericConverter_, and _Formatter_ beans.

   - Support for _HttpMessageConverters_.

   - Automatic registration of _MessageCodesResolver_.

   - Static _index.html_ support.

   - Automatic use of a _ConfigurableWebBindingInitializer_ bean.

   - Custom _Favicon_ support.

** _InternalResourceViewResolver_ handles the translation of view names and JSP pages. It is the default view resolver.

** Controller Advice
   - Handle common exceptions thrown by all controllers

     #+begin_src java

       @ControllerAdvice
       public class MissingRecordsHandler {

           @ExceptionHandler(NotFoundException.class)
           @ResponseStatus(value= HttpStatus.NOT_FOUND)
           public ModelAndView notFound(HttpServletRequest req, NotFoundException nfe) {
               //...
           }
       }
     #+end_src

   - Note that `@ResponseStatus` can be used on a Class as well to add HTTP status code and reason to method return.

     #+begin_src java
       @ResponseStatus(code = HttpStatus.BAD_REQUEST, reason = "Something wrong!")
       class CustomException extends RuntimeException {}
     #+end_src
